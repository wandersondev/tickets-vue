{
  "version": 3,
  "sources": ["../../vuetify/src/composables/goto.ts"],
  "sourcesContent": ["// Utilities\nimport { inject, toRef } from 'vue'\nimport { useRtl } from './locale'\nimport { clamp, consoleWarn, easingPatterns, mergeDeep, PREFERS_REDUCED_MOTION, refElement } from '@/util'\n\n// Types\nimport type { ComponentPublicInstance, InjectionKey, Ref } from 'vue'\nimport type { LocaleInstance, RtlInstance } from './locale'\nimport type { EasingFunction } from '@/util'\n\nexport interface GoToInstance {\n  rtl: Ref<boolean>\n  options: InternalGoToOptions\n}\n\nexport interface InternalGoToOptions {\n  container: ComponentPublicInstance | HTMLElement | string\n  duration: number\n  layout: boolean\n  offset: number\n  easing: string | EasingFunction\n  patterns: Record<string, EasingFunction>\n}\n\nexport type GoToOptions = Partial<InternalGoToOptions>\n\nexport const GoToSymbol: InjectionKey<GoToInstance> = Symbol.for('vuetify:goto')\n\nfunction genDefaults () {\n  return {\n    container: undefined,\n    duration: 300,\n    layout: false,\n    offset: 0,\n    easing: 'easeInOutCubic' satisfies keyof typeof easingPatterns,\n    patterns: easingPatterns,\n  }\n}\n\nfunction getContainer (el?: ComponentPublicInstance | HTMLElement | string) {\n  return getTarget(el) ?? (document.scrollingElement || document.body) as HTMLElement\n}\n\nfunction getTarget (el: ComponentPublicInstance | HTMLElement | string | undefined) {\n  return (typeof el === 'string') ? document.querySelector<HTMLElement>(el) : refElement(el)\n}\n\nfunction getOffset (target: any, horizontal?: boolean, rtl?: boolean): number {\n  if (typeof target === 'number') return horizontal && rtl ? -target : target\n\n  let el = getTarget(target)\n  let totalOffset = 0\n  while (el) {\n    totalOffset += horizontal ? el.offsetLeft : el.offsetTop\n    el = el.offsetParent as HTMLElement\n  }\n\n  return totalOffset\n}\n\nexport function createGoTo (\n  options: GoToOptions| undefined,\n  locale: LocaleInstance & RtlInstance\n): GoToInstance {\n  return {\n    rtl: locale.isRtl,\n    options: mergeDeep(genDefaults(), options) as InternalGoToOptions,\n  }\n}\n\nexport async function scrollTo (\n  _target: ComponentPublicInstance | HTMLElement | number | string,\n  _options: GoToOptions,\n  horizontal?: boolean,\n  goTo?: GoToInstance,\n) {\n  const property = horizontal ? 'scrollLeft' : 'scrollTop'\n  const options = mergeDeep(goTo?.options ?? genDefaults(), _options)\n  const rtl = goTo?.rtl.value\n  const target = (typeof _target === 'number' ? _target : getTarget(_target)) ?? 0\n  const container = options.container === 'parent' && target instanceof HTMLElement\n    ? target.parentElement!\n    : getContainer(options.container)\n  const ease = PREFERS_REDUCED_MOTION() ? options.patterns.instant\n    : typeof options.easing === 'function' ? options.easing\n    : options.patterns[options.easing]\n\n  if (!ease) throw new TypeError(`Easing function \"${options.easing}\" not found.`)\n\n  let targetLocation: number\n  if (typeof target === 'number') {\n    targetLocation = getOffset(target, horizontal, rtl)\n  } else {\n    targetLocation = getOffset(target, horizontal, rtl) - getOffset(container, horizontal, rtl)\n\n    if (options.layout) {\n      const styles = window.getComputedStyle(target)\n      const layoutOffset = styles.getPropertyValue('--v-layout-top')\n\n      if (layoutOffset) targetLocation -= parseInt(layoutOffset, 10)\n    }\n  }\n\n  targetLocation += options.offset\n  targetLocation = clampTarget(container, targetLocation, !!rtl, !!horizontal)\n\n  const startLocation = container[property] ?? 0\n\n  if (targetLocation === startLocation) return Promise.resolve(targetLocation)\n\n  const startTime = performance.now()\n\n  return new Promise(resolve => requestAnimationFrame(function step (currentTime: number) {\n    const timeElapsed = currentTime - startTime\n    const progress = timeElapsed / options.duration\n    const location = Math.floor(\n      startLocation +\n      (targetLocation - startLocation) *\n      ease(clamp(progress, 0, 1))\n    )\n\n    container[property] = location\n\n    // Allow for some jitter if target time has elapsed\n    if (progress >= 1 && Math.abs(location - container[property]) < 10) {\n      return resolve(targetLocation)\n    } else if (progress > 2) {\n      // The target might not be reachable\n      consoleWarn('Scroll target is not reachable')\n      return resolve(container[property])\n    }\n\n    requestAnimationFrame(step)\n  }))\n}\n\nexport function useGoTo (_options: GoToOptions = {}) {\n  const goToInstance = inject(GoToSymbol)\n  const { isRtl } = useRtl()\n\n  if (!goToInstance) throw new Error('[Vuetify] Could not find injected goto instance')\n\n  const goTo = {\n    ...goToInstance,\n    // can be set via VLocaleProvider\n    rtl: toRef(() => goToInstance.rtl.value || isRtl.value),\n  }\n\n  async function go (\n    target: ComponentPublicInstance | HTMLElement | string | number,\n    options?: Partial<GoToOptions>,\n  ) {\n    return scrollTo(target, mergeDeep(_options, options), false, goTo)\n  }\n\n  go.horizontal = async (\n    target: ComponentPublicInstance | HTMLElement | string | number,\n    options?: Partial<GoToOptions>,\n  ) => {\n    return scrollTo(target, mergeDeep(_options, options), true, goTo)\n  }\n\n  return go\n}\n\n/**\n * Clamp target value to achieve a smooth scroll animation\n * when the value goes outside the scroll container size\n */\nfunction clampTarget (\n  container: HTMLElement,\n  value: number,\n  rtl: boolean,\n  horizontal: boolean,\n) {\n  const { scrollWidth, scrollHeight } = container\n  const [containerWidth, containerHeight] = container === document.scrollingElement\n    ? [window.innerWidth, window.innerHeight]\n    : [container.offsetWidth, container.offsetHeight]\n\n  let min: number\n  let max: number\n\n  if (horizontal) {\n    if (rtl) {\n      min = -(scrollWidth - containerWidth)\n      max = 0\n    } else {\n      min = 0\n      max = scrollWidth - containerWidth\n    }\n  } else {\n    min = 0\n    max = scrollHeight + -containerHeight\n  }\n\n  return clamp(value, min, max)\n}\n"],
  "mappings": "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",
  "names": ["GoToSymbol", "Symbol", "for", "genDefaults", "container", "undefined", "duration", "layout", "offset", "easing", "patterns", "easingPatterns", "getContainer", "el", "getTarget", "document", "scrollingElement", "body", "querySelector", "refElement", "getOffset", "target", "horizontal", "rtl", "totalOffset", "offsetLeft", "offsetTop", "offsetParent", "createGoTo", "options", "locale", "isRtl", "mergeDeep", "scrollTo", "_target", "_options", "goTo", "property", "value", "HTMLElement", "parentElement", "ease", "PREFERS_REDUCED_MOTION", "instant", "TypeError", "targetLocation", "styles", "window", "getComputedStyle", "layoutOffset", "getPropertyValue", "parseInt", "clampTarget", "startLocation", "Promise", "resolve", "startTime", "performance", "now", "requestAnimationFrame", "step", "currentTime", "timeElapsed", "progress", "location", "Math", "floor", "clamp", "abs", "consoleWarn", "useGoTo", "arguments", "length", "goToInstance", "inject", "useRtl", "Error", "toRef", "go", "scrollWidth", "scrollHeight", "containerWidth", "containerHeight", "innerWidth", "innerHeight", "offsetWidth", "offsetHeight", "min", "max"]
}
